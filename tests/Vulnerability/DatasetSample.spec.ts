import { describe, expect, it } from 'vitest';

import { DatasetSample } from '../../src/Vulnerability/DatasetSample';
import { Vulnerability, toDatasetMap, toStringMap } from '../../src/Vulnerability/Vulnerability';

describe('Dataset Map Validations', () => {
    const vulnerabilities: readonly Vulnerability[] = Object.freeze(
        Object.values(Vulnerability).filter((value): value is Vulnerability => typeof value === 'number'),
    );
    const invalidSamples: readonly unknown[] | readonly DatasetSample[] = Object.freeze([
        { code: 123, label: 1 }, // invalid code type
        { code: 'console.log("Hello World")', label: 2 }, // invalid label
        { code: '', label: 0 }, // empty code snippet
        { label: 1 }, // missing code property
        { code: 'console.log("Hello World")' }, // missing label property
    ]);

    vulnerabilities.forEach((vulnerability: Vulnerability) => {
        const vulnLabel: string = toStringMap[vulnerability];
        it(`should validate valid dataset for '${vulnLabel}'`, () => {
            const validSamples: readonly DatasetSample[] = toDatasetMap[vulnerability];
            const dataset: readonly DatasetSample[] = [...validSamples];
            const invalidEntries = validateDataset(vulnerability, dataset);
            expect(invalidEntries).toHaveLength(0);
        });
        invalidSamples.forEach((sample, index) => {
            it(`should return errors for invalid sample ${index + 1} for '${vulnLabel}'`, () => {
                const dataset = [sample as DatasetSample]; // cast `unknown` to `DatasetSample`
                const invalidEntries: readonly DatasetMetadata[] = validateDataset(vulnerability, dataset);
                const isInsecureAuthEdgeCase = vulnerability === Vulnerability.InsecureAuth;
                const expectedCount = isInsecureAuthEdgeCase ? 0 : 1;
                expect(invalidEntries.length).toBeGreaterThanOrEqual(expectedCount);
                if (expectedCount > 0) {
                    const { codeSnippet, kind } = invalidEntries[0];
                    expect(codeSnippet).toEqual(sample);
                    expect(kind).toEqual(toStringMap[vulnerability]);
                }
            });
        });
    });
});

const datasetSampleLabels = new Set<DatasetSample['label']>([0, 1]);
const DatasetError = Object.freeze({
    EmptyCode: 'EmptyCode',
    InvalidCodeType: 'InvalidCodeType',
    InvalidLabel: 'InvalidLabel',
    InvalidLabelType: 'InvalidLabelType',
    InvalidProp: 'InvalidProp',
    None: 'None',
} as const);
type DatasetError = (typeof DatasetError)[keyof typeof DatasetError];
type ErrorKeyValueTuple = [DatasetError, string?];
type DatasetMetadata = {
    codeSnippet: DatasetSample;
    err?: DatasetError;
    index: number;
    kind: string;
    reason?: string;
};

function validateDataset(kind: Vulnerability, dataset: readonly DatasetSample[]): readonly DatasetMetadata[] {
    return dataset
        .flatMap((value, index) => {
            const errors = new Map<ErrorKeyValueTuple[0], ErrorKeyValueTuple[1]>();
            if (!('code' in value) || !('label' in value)) {
                if (!('code' in value)) errors.set(DatasetError.InvalidProp, `Expected 'code' property in 'DatasetSample'`);
                if (!('label' in value)) errors.set(DatasetError.InvalidProp, `Expected 'label' property in 'DatasetSample'`);
            } else {
                if (typeof value.code !== 'string') {
                    errors.set(DatasetError.InvalidCodeType, `Expected code to be a 'string'. Actual: '${typeof value.code}'.`);
                }
                if (typeof value.label !== 'number') {
                    errors.set(DatasetError.InvalidLabelType, `Expected label to be a 'number'. Actual: '${typeof value.label}'.`);
                }
                const isInsecureAuthEdgeCase = kind === Vulnerability.InsecureAuth;
                const expectedMinCodeLen = isInsecureAuthEdgeCase ? 0 : 1;
                if (value.code.length < expectedMinCodeLen) {
                    errors.set(DatasetError.EmptyCode, 'Found empty code snippet.');
                }
                if (!datasetSampleLabels.has(value.label)) {
                    const expected: string = [...datasetSampleLabels].join(' | ');
                    errors.set(DatasetError.InvalidLabel, `Invalid label. Expected: '${expected}'. Actual: '${value.label}'.`);
                }
            }
            const meta: DatasetMetadata = {
                codeSnippet: value,
                err: undefined,
                index: index,
                kind: toStringMap[kind],
                reason: undefined,
            } as const;
            return errors.size > 0
                ? [...errors.entries()].map(([err, reason]: ErrorKeyValueTuple) => ({ ...meta, err, reason } as DatasetMetadata))
                : [{ ...meta, err: DatasetError.None } as DatasetMetadata];
        })
        .filter((entry) => entry.err !== DatasetError.None);
}
