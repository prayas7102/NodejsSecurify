import { DatasetSample } from './DatasetSample';

// Example dataset (Replace this with your actual dataset) SNYK
// Certainly, here are 10 more examples of insecure authentication practices in Node.js applications:

// DONE 1. **Hardcoded Credentials**: Storing credentials (such as usernames and passwords) directly in the source code, making them accessible to anyone with access to the codebase.

// DONE 2. **Weak Passwords**: Allowing users to set weak passwords that are easily guessable or crackable, such as "password123" or "admin123".

// DONE 3. **No Password Hashing**: Storing passwords in plain text instead of securely hashing them using algorithms like bcrypt or Argon2.

// DONE 6. **Insecure Session Management**: Using insecure or predictable session IDs, not expiring sessions properly, or not using HTTPS for secure transmission of session data.

// DONE 8. **Insecure Token Storage**: Storing authentication tokens in insecure locations, such as local storage, making them susceptible to theft through cross-site scripting (XSS) attacks.

// DONE 10. **Weak JWT (JSON Web Token) Security**: Using weak algorithms or not signing JWTs properly, leading to token forgery or tampering.

export const dataset: DatasetSample[] = [
  {
    'code': `  res.cookie('token', token, { httpOnly: true, secure: true });
        `,
    'label': 0
  }, {
    'code': `app.use(csp({
            directives: {
              defaultSrc: ["'self'"],
              scriptSrc: ["'self'", "code.jquery.com"],
              objectSrc: ["'none'"],
              styleSrc: ["'self'", "maxcdn.bootstrapcdn.com"],
              imgSrc: ["'self'"],
              mediaSrc: ["'none'"],
              frameSrc: ["'none'"],
              fontSrc: ["'self'", "maxcdn.bootstrapcdn.com"]
            }
          }));`,
    'label': 0
  }, {
    'code': `  res.cookie('token', token, { sameSite: 'Lax' });
        `,
    'label': 0
  }, {
    'code': `const updateUserPassword = async (newPassword) => {
            try {
              // Generate a new hash for the updated password
              const newHashedPassword = await bcrypt.hash(newPassword, 10);
          
              // Update the hashed password in the database
              console.log('Updated Hashed Password:', newHashedPassword);
            } catch (error) {
              console.error('Error updating password:', error);
            }
          };`,
    'label': 0
  }, {
    'code': ` const { username, password } = req.body;

        try {
          // Retrieve hashed password from the database based on the username
          const hashedPassword = '...'; // Retrieve hashed password from the database
      
          // Compare the hashed password with the provided password
          const match = await bcrypt.compare(password, hashedPassword);
      
          if (match) {
            res.status(200).send('Login successful.');
          } else {
            res.status(401).send('Invalid credentials.');
          }`,
    'label': 0
  }, {
    'code': ` // Compare the hashed password with the plaintext password
        bcrypt.compare(plaintextPassword, hash, (err, result) => {
          if (err) throw err;
      
          console.log('Password Match:', result);
      });`,
    'label': 0
  }, {
    'code': `const hashPassword = async () => {
            try {
              // Generate a salt and hash the password
              const hash = await bcrypt.hash(plaintextPassword, 10);
          
              // Store the hash in the database
              console.log('Hashed Password:', hash);
          
              // Compare the hashed password with the plaintext password
              const match = await bcrypt.compare(plaintextPassword, hash);
              console.log('Password Match:', match);
            } catch (error) {
              console.error('Error:', error);
            }
          };`,
    'label': 0
  }, {
    'code': ` try {
            // Generate a salt and hash the password
            const hashedPassword = await bcrypt.hash(password, 10);
        
            // Store the hashed password and username in the database
            // ...
        
            res.status(200).send('User registered successfully.');
          } catch (error) {
            res.status(500).send('Error registering user.');
          }`,
    'label': 0
  }, {
    'code': `const config = require('./config');

        const username = config.db.username;
        const password = config.db.password;
        
        // Use the credentials in your application
        connectToDatabase(username, password);
        `,
    'label': 0
  }, {
    'code': `const username = process.env.DB_USERNAME;
        const password = process.env.DB_PASSWORD;
        
        // Use the credentials in your application
        connectToDatabase(username, password);
        `,
    'label': 0
  }, {
    'code': `const vault = require('vault-sdk');

        async function fetchCredentials() {
          const username = await vault.getSecret('database/username');
          const password = await vault.getSecret('database/password');
        
          // Use the credentials in your application
          connectToDatabase(username, password);
        }
        
        fetchCredentials();
        `,
    'label': 0
  }, {
    'code': `const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
          });`,
    'label': 0
  }, {
    'code': ` const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

        if (!strongPasswordRegex.test(password)) {
          return res.status(400).send('Password is too weak. Choose a stronger password.');
        }`,
    'label': 0
  }, {
    'code': `const bcrypt = require('bcrypt');

        app.post('/register', async (req, res) => {
          const { username, password } = req.body;
        
          // Hash the password
          const hashedPassword = await bcrypt.hash(password, 10);
        
          // Save hashed password to the database
          saveUserToDatabase(username, hashedPassword);
        
          res.send('User registered successfully.');
        });
        `,
    'label': 0
  }, {
    'code': `const bcrypt = require('bcrypt');

        app.post('/register', async (req, res) => {
          const { username, password } = req.body;
        
          // Generate a random salt
          const salt = await bcrypt.genSalt(10);
        
          // Hash the password with the salt
          const hashedPassword = await bcrypt.hash(password, salt);
        
          // Save hashed password and salt to the database
          saveUserToDatabase(username, { hashedPassword, salt });
        
          res.send('User registered successfully.');
        });
        `,
    'label': 0
  }, {
    'code': `const passwordStrength = require('password-strength');

        app.post('/register', (req, res) => {
          const { username, password } = req.body;
        
          const strength = passwordStrength(password);
        
          if (strength < 0.5) {
            return res.status(400).send('Password is too weak. Choose a stronger password.');
          }
        
          // Save user with a strong password (simplified)
          saveUserToDatabase(username, password);
        
          res.send('User registered successfully.');
        });
        `,
    'label': 0
  }, {
    'code': `const passwordValidator = require('password-validator');

        const passwordSchema = new passwordValidator();
        passwordSchema
          .is().min(8) // Minimum length 8
          .is().max(100) // Maximum length 100
          .has().uppercase() // Must have uppercase letters
          .has().lowercase() // Must have lowercase letters
          .has().digits() // Must have digits
          .has().not().spaces(); // Should not have spaces`,
    'label': 0
  }, {
    'code': `const OAuth2Strategy = require('passport-oauth2').Strategy;
        const app = express();
        
        passport.use('oauth2', new OAuth2Strategy({
          authorizationURL: 'https://oauth-provider.com/authorize',
          tokenURL: 'https://oauth-provider.com/token',
          clientID: 'your-client-id',
          clientSecret: 'your-client-secret',
          callbackURL: 'https://your-app.com/callback',
        }, (accessToken, refreshToken, profile, done) => {
          // Handle authentication and user data retrieval
          // ...
          return done(null, profile);
        }));
        
        app.use(passport.initialize());
        
        app.get('/login', passport.authenticate('oauth2'));
        
        app.get('/callback', passport.authenticate('oauth2', {
          successRedirect: '/dashboard',
          failureRedirect: '/login',
        }));`,
    'label': 0
  }, {
    'code': `const express = require('express');
        const session = require('express-session');
        const passport = require('passport');
        const LocalStrategy = require('passport-local').Strategy;
        const app = express();
        
        app.use(session({
          secret: 'your-secret-key',
          resave: false,
          saveUninitialized: true,
          cookie: {
            secure: true,
            httpOnly: true,
            maxAge: 3600000,
          },
        }));`,
    'label': 0
  }, {
    'code': `app.use(session({
            genid: (req) => {
              return crypto.randomBytes(16).toString('hex'); // Generate secure session IDs
            },
            secret: 'your-secret-key',
            resave: false,
            saveUninitialized: true,
            cookie: {
              secure: true,
              httpOnly: true,
              maxAge: 3600000,
            },
          }));`,
    'label': 0
  }, {
    'code': `app.use(session({
            secret: 'your-secret-key',
            resave: false,
            saveUninitialized: true,
            cookie: {
              secure: true, // Require HTTPS for secure transmission of session data
              httpOnly: true, // Prevent client-side JavaScript from accessing cookies
              maxAge: 3600000, // Session expires after 1 hour of inactivity
            },
          }));`,
    'label': 0
  },
  {
    'code': `// 
        const username = "admin";
        const password = "password123";
        `,
    'label': 1
  },
  {
    'code': `// 
        const username = process.env.APP_USERNAME;
        const password = process.env.APP_PASSWORD;
        `,
    'label': 0
  },
  {
    'code': `// 
        const dbConfig = {
          user: "db_admin",
          password: "db_password123",
          database: "mydb"
        };
        `,
    'label': 1
  },
  {
    'code': `// 
        const dbConfig = {
          user: process.env.DB_USER,
          password: process.env.DB_PASSWORD,
          database: process.env.DB_NAME
        };
        `,
    'label': 0
  }, {
    'code': `// 
        const apiKey = "my_api_key";
        `,
    'label': 1
  },
  {
    'code': `// 
        const apiKey = process.env.API_KEY;
        `,
    'label': 0
  }, {
    'code': `// 
        const oauthClientSecret = "my_oauth_client_secret";
        `,
    'label': 1
  },
  {
    'code': `// 
        const oauthClientSecret = process.env.OAUTH_CLIENT_SECRET;
        `,
    'label': 0
  }, {
    'code': `// 
        const encryptionKey = "my_encryption_key";
        `,
    'label': 1
  },
  {
    'code': `// 
        const encryptionKey = process.env.ENCRYPTION_KEY;
        `,
    'label': 0
  },
  {
    'code': `const users = [
    { username: 'admin', password: 'admin123', role: 'admin' },
    { username: 'user', password: 'user123', role: 'user' }
  ];
  
  app.use(bodyParser.json());
  
  app.post('/login', (req, res) => {
    const { username, password } = req.body;
    const user = users.find(u => u.username === username && u.password === password);
`,
    'label': 1
  },
  {
    'code': `if (inputPassword == storedPassword) {
            // Allow access
        }
        `,
    'label': 1
  },
  {
    'code': `if (userInput === 'admin' && passInput === 'admin123') {
            // Grant admin privileges
        }
        `,
    'label': 1
  },
  {
    'code': `jwt.sign(payload, secretKey);
        `,
    'label': 1
  },
  {
    'code': `jwt.sign(payload, secretKey, { expiresIn: '1h' });
        `,
    'label': 0
  },
  {
    'code': `jwt.sign({ userId: 123, isAdmin: true }, secretKey);
        `,
    'label': 1
  },
  {
    'code': `jwt.sign({ userId: 123 }, secretKey);
        `,
    'label': 0
  },
  {
    'code': `// 
        const decoded = jwt.decode(token);
        if (decoded.exp < Date.now() / 1000) {
          // Token expired, but not validated using jwt.verify
        }
        
        `,
    'label': 1
  },
  {
    'code': `jwt.verify(token, publicKey);
        `,
    'label': 0
  },
  {
    'code': `// 
        localStorage.setItem('token', token);
        
        `,
    'label': 1
  },
  {
    'code': `httpOnlyCookies.set('token', token);
        `,
    'label': 0
  },
  {
    'code': `const token = base64Encode(header) + '.' + base64Encode(payload) + '.' + base64Encode(signature);
        `,
    'label': 1
  },
  {
    'code': `jwt.sign(payload, secretKey);
        `,
    'label': 0
  },
  {
    'code': `const users = [
            { username: 'alice', password: 'password123', role: 'user' },
            { username: 'bob', password: 'ilovepizza', role: 'user' }
        ];
        
        app.post('/authenticate', (req, res) => {
            const { username, password } = req.body;
            
            const user = users.find(u => u.username === username && u.password === password);
            
            if (user) {
                // : Sending sensitive information in response
                res.json({ message: 'Authentication successful', token: user.password });
            } else {
                res.status(401).json({ message: 'Authentication failed' });
            }
        });
        `,
    'label': 1
  },
  {
    'code': `const bcrypt = require('bcrypt');
        const saltRounds = 10;
        
        // Hashing the user's password before storing it in the database
        const plaintextPassword = 'user_password';
        bcrypt.hash(plaintextPassword, saltRounds, (err, hash) => {
          if (err) {
            console.error('Error hashing password:', err);
            return;
          }
          // Store the 'hash' in the database as the user's password
          console.log('Hashed password:', hash);
        });
        `,
    'label': 0
  },
  {
    'code': `const express = require('express');
        const bodyParser = require('body-parser');
        const bcrypt = require('bcrypt');
        
        const app = express();
        app.use(bodyParser.json());
        
        // Simulated user database
        const users = [];
        
        app.post('/register', (req, res) => {
          const { username, password } = req.body;
          
          // Hash the password before storing it
          bcrypt.hash(password, saltRounds, (err, hash) => {
            if (err) {
              console.error('Error hashing password:', err);
              res.status(500).send('Internal Server Error');
              return;
            }
            
            // Store the user in the database with the hashed password
            users.push({ username, passwordHash: hash });
            res.status(200).send('User registered successfully');
          });
        });
        
        app.listen(3000, () => {
          console.log('Server started on port 3000');
        });
        `,
    'label': 0
  },
  {
    'code': `app.post('/login', (req, res) => {
            const { username, password } = req.body;
            
            // Find the user in the database
            const user = users.find(u => u.username === username);
            if (!user) {
              res.status(401).send('User not found');
              return;
            }
            
            // Compare the provided password with the stored hash
            bcrypt.compare(password, user.passwordHash, (err, result) => {
              if (err || !result) {
                res.status(401).send('Authentication failed');
                return;
              }
              res.status(200).send('Login successful');
            });
          });
          `,
    'label': 0
  },
  {
    'code': `if (inputPassword === storedPassword) {
            // Authenticate based on password
        }
        `,
    'label': 1
  },
  {
    'code': `if (userInput === 'guest' || passInput === 'guest123') {
            // Provide guest privileges
        }
        `,
    'label': 1
  },
  {
    'code': `if (userInput === 'admin' && passInput === '123456') {
            // Authenticate as admin with weak password
        }
        `,
    'label': 1
  },
  {
    'code': `if (inputUsername === 'admin' && inputPassword === 'admin') {
            // Authenticate admin based on input values
        }
        `,
    'label': 1
  },
  {
    'code': `if (userInput === 'admin' && passInput === 'admin') {
            // Provide admin privileges
        }
        `,
    'label': 1
  },
  {
    'code': ``,
    'label': 1
  },
  {
    'code': ``,
    'label': 1
  }, {
    'code': ``,
    'label': 1
  }, {
    'code': ``,
    'label': 1
  }, {
    'code': ``,
    'label': 1
  }, {
    'code': `const helmet = require('helmet');
        app.use(helmet());
        `,
    'label': 0
  }, {
    'code': `const jwt = require('jsonwebtoken');
        const token = jwt.sign({ userId: user.id }, 'your-secret-key', { expiresIn: '1h' });
        `,
    'label': 0
  }, {
    'code': `const sso = require('sso-library');
        app.use(sso.middleware({ secret: 'your-secret-key' }));
        `,
    'label': 0
  }, {
    'code': `const session = require('express-session');
        const RedisStore = require('connect-redis')(session);
        
        app.use(session({
          store: new RedisStore({ url: 'redis://localhost:6379' }),
          secret: 'your-secret-key',
          resave: false,
          saveUninitialized: true
        }));
        `,
    'label': 0
  }, {
    'code': `app.use((req, res, next) => {
            req.session.nowInMinutes = Math.floor(Date.now() / 60e3);
            next();
          });
          
          app.use((req, res, next) => {
            if (req.session.nowInMinutes - req.session.creationTime > SESSION_TIMEOUT_MINUTES) {
              // Expire the session
            }
            next();
          });
          `,
    'label': 0
  }, {
    'code': `const session = require('express-session');
        app.use(session({ secret: 'your-secret-key', resave: false, saveUninitialized: true }));
        `,
    'label': 0
  }, {
    'code': `req.session.cookie.expires = new Date(Date.now() + 3600000); // 1 hour
        `,
    'label': 0
  }, {
    'code': `res.cookie('sessionID', sessionId, { httpOnly: true, secure: true });
        `,
    'label': 0
  }, {
    'code': `const uuid = require('uuid');
        const sessionId = uuid.v4();
        `,
    'label': 0
  }, {
    'code': `const https = require('https');
        const fs = require('fs');
        
        const options = {
          key: fs.readFileSync('private-key.pem'),
          cert: fs.readFileSync('public-cert.pem')
        };
        
        const server = https.createServer(options, app);
        `,
    'label': 0
  }, {
    'code': `// Not properly sanitizing user input
        app.get('/search', (req, res) => {
          const searchTerm = req.query.term;
          res.render('search', { searchTerm });
        });
        `,
    'label': 1
  }, {
    'code': `// Regenerating session ID without destroying the old session
        app.post('/logout', (req, res) => {
          req.session.regenerate();
        });
        `,
    'label': 1
  }, {
    'code': `// Not binding sessions to IP addresses
        app.use(session({
          secret: 'your-secret-key',
          cookie: { secure: true },
          proxy: true
        }));
        `,
    'label': 1
  }, {
    'code': `// Not clearing session data upon logout
        app.post('/logout', (req, res) => {
          req.session.destroy();
        });
        `,
    'label': 1
  }, {
    'code': `// Not validating or sanitizing serialized session data
        app.use(session({
          secret: 'your-secret-key',
          saveUninitialized: false,
          resave: false,
          cookie: { secure: true }
        }));
        `,
    'label': 1
  }, {
    'code': `// Using short session IDs
        const sessionId = crypto.randomBytes(16).toString('hex');
        `,
    'label': 1
  }, {
    'code': `// Not providing a way to revoke user sessions
        app.post('/revoke-session/:sessionId', (req, res) => {
          // ...
        });
        `,
    'label': 1
  }, {
    'code': `// Not implementing session data integrity checks
        app.use(session({
          secret: 'your-secret-key',
          cookie: { secure: true },
          rolling: true
        }));
        `,
    'label': 1
  }, {
    'code': `// Not setting SameSite attribute for cookies
        app.use(session({
          secret: 'your-secret-key',
          cookie: { secure: true }
        }));
        `,
    'label': 1
  }, {
    'code': `// Storing session tokens in plaintext files
        fs.writeFileSync('session-token.txt', 'your-session-token');
        `,
    'label': 1
  }, {
    'code': `// Using a low-entropy session secret
        app.use(session({ secret: 'low-entropy-secret' }));
        `,
    'label': 1
  }, {
    'code': `// Not using HTTPS for transmitting session data
        app.use(session({ secret: 'your-secret-key' }));
        `,
    'label': 1
  }, {
    'code': `// Storing sessions in memory (vulnerable to DoS attacks)
        app.use(session({ secret: 'your-secret-key', store: new MemoryStore() }));
        `,
    'label': 1
  }, {
    'code': `// Not expiring sessions
        app.use(session({ secret: 'your-secret-key' }));
        `,
    'label': 1
  }, {
    'code': `// Storing session ID in URL
        app.get('/dashboard/:sessionId', (req, res) => {
          // ...
        });
        `,
    'label': 1
  }, {
    'code': `//  session ID generation
        const sessionId = Math.random().toString();
        `,
    'label': 1
  }, {
    'code': `// : Storing session data in  storage
        app.post("/login", (req, res) => {
          req.session.username = req.body.username; // : Session data not properly secured
        });
        `,
    'label': 1
  }, {
    'code': `// : Using a weak algorithm for JWT signing
        const jwtToken = jwt.sign(payload, "-secret");
        `,
    'label': 1
  }, {
    'code': `// : No password reset token expiry check
        app.post("/request-password-reset", (req, res) => {
          const user = findUserByEmail(req.body.email);
          if (user) {
            const resetToken = generateResetToken();
            user.resetToken = resetToken;
            // No expiry date set for reset token
          }
        });
        `,
    'label': 1
  }, {
    'code': `// : No password hashing and salting
        const userSchema = new mongoose.Schema({
          username: String,
          password: String, // : Storing passwords as plain text
        });
        
        const User = mongoose.model("User", userSchema);
        
        app.post("/login", (req, res) => {
          User.findOne({ username: req.body.username }, (err, user) => {
            if (err || !user) {
              return res.status(401).json({ error: "Invalid credentials." });
            }
            if (user.password === req.body.password) {
              // Successful authentication
            }
          });
        });
        `,
    'label': 1
  }, {
    'code': `// : Not enforcing password complexity
        const validatePassword = password => {
          if (password.length < 8) {
            return "Password must be at least 8 characters long.";
          }
        };
        
        app.post("/register", (req, res) => {
          const validationError = validatePassword(req.body.password);
          if (validationError) {
            return res.status(400).json({ error: validationError });
          }
          // Create user
        });
        `,
    'label': 1
  }, {
    'code': `// : Storing passwords in plain text
        const userSchema = new mongoose.Schema({
          username: String,
          password: String, // : Storing passwords as plain text
        });
        
        const User = mongoose.model("User", userSchema);
        `,
    'label': 1
  }, {
    'code': `// : Storing password in plain text
        const users = [
          { username: "user1", password: "password123" },
          // ...
        ];
        
        app.post("/login", (req, res) => {
          const user = users.find(u => u.username === req.body.username);
          if (user && user.password === req.body.password) {
            // Successful authentication
          }
        });
        `,
    'label': 1
  },
];