import { assert } from 'node:console';

import { DatasetSample } from './DatasetSample';
import {
    Vulnerability, // enum & type
    detectedToStringMap,
    notDetectedToStringMap,
    toDatasetMap,
    toStringMap,
} from './VulnerabilityTypes';

// Helper function for assertions with consistent error messaging.
function assertCondition(condition: boolean, message: string): asserts condition {
    // if (!condition) { throw new Error(message); } //> runtime panic
    assert(condition, message); //> graceful error logging
}

// NOTE: Property testing, libraries like `fast-check` in JavaScript could help generate a wide
// range of input data to test edge cases. Could be useful for dataset validation. Seems like the
// cousin of `quickcheck`!
export function testVulnerability() {
    const vulnerabilities = Object.values(Vulnerability) //
        .filter((value): value is Vulnerability => typeof value === 'number') as readonly Vulnerability[];

    vulnerabilities.forEach(testToStringMap);
    vulnerabilities.forEach(testDetectedToStringMap);
    vulnerabilities.forEach(testNotDetectedToStringMap);
    vulnerabilities.forEach(testToDatasetMap);
}

// Test that enum values map correctly to their corresponding strings and datasets.
function testToStringMap(kind: Vulnerability): void {
    assertCondition(toStringMap[kind] !== undefined, `Missing 'toStringMap' entry for Vulnerability '${kind}'.`);
}

function testDetectedToStringMap(kind: Vulnerability): void {
    const detectionMsgPrefix = '==> ';
    const detected = detectedToStringMap[kind];
    assertCondition(detected !== undefined, `Missing 'detectedToStringMap' entry for Vulnerability '${kind}'.`);
    assertCondition(
        detected.startsWith(detectionMsgPrefix),
        `Expected 'detectedToStringMap[${kind}]' to start with ${detectionMsgPrefix}. Actual: '${detected.slice(detectionMsgPrefix.length)}'.`,
    );
}

function testNotDetectedToStringMap(kind: Vulnerability): void {
    const detectionMsgPrefix = '==> ';
    const notDetected = notDetectedToStringMap[kind];
    assertCondition(notDetected !== undefined, `Missing 'notDetectedToStringMap' entry for Vulnerability '${kind}'.`);
    assertCondition(
        notDetected.startsWith(detectionMsgPrefix),
        `Expected 'notDetectedToStringMap[${kind}]' to start with ${detectionMsgPrefix}. Actual: '${notDetected.slice(detectionMsgPrefix.length)}'.`,
    );
}

const datasetSampleLabels = new Set([0, 1]) as Set<DatasetSample['label']>;

const DatasetError = {
    EmptyCode: 'Found empty code snippet',
    InvalidCodeType: `Expected code to be a 'string'`,
    InvalidLabel: `Invalid label. Expected: '${[...datasetSampleLabels].join(' | ')}'`,
    InvalidLabelType: `Expected label to be a 'number'`,
    InvalidProp: `Invalid property in 'DatasetSample'`,
    None: 'None', // no error
};

type DatasetError = (typeof DatasetError)[keyof typeof DatasetError];

type DatasetMetadata = {
    err: DatasetError | undefined;
    index: number;
    kind: string;
    codeSnippet: DatasetSample;
};

// Validate dataset entries and return metadata for any errors found.
function validateDataset(kind: Vulnerability, dataset: readonly DatasetSample[]): readonly DatasetMetadata[] {
    return dataset
        .flatMap((value, index) => {
            const errors = new Set() as Set<string>;
            if (!('code' in value && 'label' in value)) {
                errors.add(DatasetError.InvalidProp);
            } else {
                if (typeof value.code !== 'string') errors.add(`${DatasetError.InvalidCodeType}. Actual: '${typeof value.code}'.`);
                if (typeof value.label !== 'number') errors.add(`${DatasetError.InvalidLabelType}. Actual: '${typeof value.label}'.`);
                const expectedMinCodeLength = kind === Vulnerability.InsecureAuth ? 0 : 1; // edge case
                if (value.code.length < expectedMinCodeLength) errors.add(`${DatasetError.EmptyCode}`);
                if (!datasetSampleLabels.has(value.label)) errors.add(`${DatasetError.InvalidLabel}. Actual: '${value.label}'.`);
            }
            assert(!errors.has(DatasetError.None)); // defensive check
            const meta: DatasetMetadata = Object.freeze({ err: undefined, index: index, kind: toStringMap[kind], codeSnippet: value } as const);
            return errors.size > 0
                ? ([...errors].map((err) => ({ ...meta, err })) as readonly DatasetMetadata[])
                : ([{ ...meta, err: DatasetError.None }] as readonly DatasetMetadata[]);
        })
        .filter((entry) => entry.err !== DatasetError.None);
}

function testToDatasetMap(kind: Vulnerability): void {
    {
        const dataset = toDatasetMap[kind] as readonly DatasetSample[];
        assertCondition(dataset !== undefined, `Missing 'toDatasetMap' entry for Vulnerability '${kind}'.`);
        assertCondition(Array.isArray(dataset) && dataset.length > 0, 'Expected non-empty dataset.');
    }

    {
        const dataset = toDatasetMap[kind] as readonly DatasetSample[];
        const invalidEntries: readonly DatasetMetadata[] = validateDataset(kind, dataset);
        assertCondition(
            invalidEntries.length === 0,
            `Found ${invalidEntries.length} invalid dataset entries:\n${invalidEntries
                .map((value: DatasetMetadata): string => JSON.stringify(value, null, 2))
                .join(', ')}`,
        );
    }
}

// NOTE: (if (value.code.length < (kind === Vulnerability.InsecureAuth ? 1 : 1)) {)
//                                                                       ^
//                                                                       Used 1 instead of 0
//                                                                       ~~~~~~~~~~~~~~~~~~~
// Example Output:
//
// Assertion failed: Found 5 invalid dataset entries:
// {
//   "err": "Found empty code snippet",
//   "index": 53,
//   "kind": "Insecure Authentication",
//   "codeSnippet": {
//     "code": "",
//     "label": 1
//   }
// }, {
//   "err": "Found empty code snippet",
//   "index": 54,
//   "kind": "Insecure Authentication",
//   "codeSnippet": {
//     "code": "",
//     "label": 1
//   }
// }, {
//   "err": "Found empty code snippet",
//   "index": 55,
//   "kind": "Insecure Authentication",
//   "codeSnippet": {
//     "code": "",
//     "label": 1
//   }
// }, {
//   "err": "Found empty code snippet",
//   "index": 56,
//   "kind": "Insecure Authentication",
//   "codeSnippet": {
//     "code": "",
//     "label": 1
//   }
// }, {
//   "err": "Found empty code snippet",
//   "index": 57,
//   "kind": "Insecure Authentication",
//   "codeSnippet": {
//     "code": "",
//     "label": 1
//   }
// }