import { dataset as bruteForceDataset } from './DetectBruteForceAttack';
import { dataset as inputValidationDataset } from './DetectInputValidation';
import { dataset as insecureAuthenticationDataset } from './InsecureAuthentication';
import { dataset as securityHeadersDataset } from './AnalyzeSecurityHeaders';

import { DatasetSample } from './DatasetSample';


// Enumerates common types of vulnerabilities.
// Note: Defined as a 'read-only' frozen object to prevent modifications.
export const Vulnerability = Object.freeze({
    BruteForce: 0,
    InputValidation: 1,
    InsecureAuth: 2,
    SecurityHeaders: 3,
    CallBackHell: 4,
    Regex: 5,
    DangerousFunctions: 6
} as const);

export type Vulnerability = (typeof Vulnerability)[keyof typeof Vulnerability];

// Map `Vulnerability` values to their `toString` descriptions.
export const toStringMap: { [key: number]: string } = Object.freeze({
    [Vulnerability.BruteForce]: 'Brute Force Attack',
    [Vulnerability.InputValidation]: 'Input Validation',
    [Vulnerability.InsecureAuth]: 'Insecure Authentication',
    [Vulnerability.SecurityHeaders]: 'Security Headers',
    [Vulnerability.CallBackHell]: 'Callback Hell',
    [Vulnerability.Regex]: 'RegExp',
    [Vulnerability.DangerousFunctions]: 'Dangerous Function',
} as const);

// Map `Vulnerability` values to their dataset samples.
export const toDatasetMap: { [key: number]: readonly DatasetSample[] } = Object.freeze({
    [Vulnerability.BruteForce]: bruteForceDataset,
    [Vulnerability.InputValidation]: inputValidationDataset,
    [Vulnerability.InsecureAuth]: insecureAuthenticationDataset,
    [Vulnerability.SecurityHeaders]: securityHeadersDataset,
} as const);

export const notDetectedToStringMap: { [key: number]: string } = Object.freeze({
    [Vulnerability.BruteForce]: `==> Code NOT vulnerable to ${toStringMap[Vulnerability.BruteForce]}`,
    [Vulnerability.InputValidation]: `==> Code has proper ${toStringMap[Vulnerability.InputValidation]}`,
    [Vulnerability.InsecureAuth]: `==> NO ${toStringMap[Vulnerability.InsecureAuth]} detected`,
    [Vulnerability.SecurityHeaders]: `==> NO Insecure ${toStringMap[Vulnerability.SecurityHeaders]} found`, // ok: security headers safe from brute force attacks
    [Vulnerability.CallBackHell]: `==> Code has proper ${toStringMap[Vulnerability.CallBackHell]}`,
    [Vulnerability.Regex]: `==> NO ${toStringMap[Vulnerability.Regex]} object detected with ReDoS-prone patterns`,
    [Vulnerability.DangerousFunctions]: `==> NO ${toStringMap[Vulnerability.DangerousFunctions]} detected`, // ok: security headers safe from brute force attacks
} as const);

export const detectedToStringMap: { [key: number]: string } = Object.freeze({
    [Vulnerability.BruteForce]: `==> Code vulnerable to ${toStringMap[Vulnerability.BruteForce]} in this file!!! `,
    [Vulnerability.InputValidation]: `==> Code has improper ${toStringMap[Vulnerability.InputValidation]}, vulnerable to DOS Attack:!!! `,
    [Vulnerability.InsecureAuth]:
    `==> Code vulnerable to ${toStringMap[Vulnerability.InsecureAuth]} in this file!!! ` +
    '\nCheck for: Hardcoded Credentials, Weak Passwords, No Password Hashing, Insecure Session Management, Insecure Token Storage, Weak JWT Security',
    [Vulnerability.SecurityHeaders]: `==> Insecure ${toStringMap[Vulnerability.SecurityHeaders]} found!!! `, // not ok: security headers NOT safe from brute force attacks
    [Vulnerability.CallBackHell]: `==> Callback hell detected! At Line no. => `,
    [Vulnerability.Regex]: `==> ${toStringMap[Vulnerability.Regex]} object detected with ReDoS-prone patterns at line `,
    [Vulnerability.DangerousFunctions]: `==> Following dangerous function detected: `,
} as const);
